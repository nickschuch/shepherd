<?php

/**
 * @file
 * Contains ua_sm_custom.module.
 */

use Drupal\Component\Utility\Crypt;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\node\Entity\Node;
use Drupal\user\Entity\User;

const UA_SM_CUSTOM_INSTANCE_LIMIT = 20;

/**
 * Implements hook_help().
 */
function ua_sm_custom_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the ua_sm_custom module.
    case 'help.page.ua_sm_custom':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('This module provides functionality specific to the UA Site Manager.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_theme().
 */
function ua_sm_custom_theme($existing, $type, $theme, $path) {
  return [
    'site_environment_status' => [
      'variables' => [
        'running' => NULL,
        'building' => NULL,
        'failed' => NULL,
        'environment' => NULL,
      ],
    ],
  ];
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * Determines available port numbers for new instances, and generates random
 * hash salt for new environments.
 */
function ua_sm_custom_node_presave(Node $entity) {
  switch ($entity->bundle()) {
    case 'ua_sm_site_instance':
      ua_sm_custom_ports($entity);
      break;

    case 'ua_sm_environment':
      ua_sm_custom_environment_defaults($entity);
      break;
  }
}

/**
 * Triggers the requested Jenkins job.
 *
 * @param string $job_name
 *   The name of the Jenkins job to run.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The site_instance entity to post the comment to, or it's parent anyway.
 */
function ua_sm_custom_run_job($job_name, EntityInterface $entity) {
  \Drupal::service('ua_sm_custom.jenkins_client')->job($job_name, $entity);
}

/**
 * Populates an environment with a new hash_salt and config sync dir.
 *
 * @param Node $environment
 *   Node to generate config default values for.
 */
function ua_sm_custom_environment_defaults(Node $environment) {
  if ($environment->field_ua_sm_config_sync->isEmpty()) {
    // Generate a config sync dir and store it for each new environment.
    $config_directories_hash = Crypt::randomBytesBase64(55);
    $environment->field_ua_sm_config_sync->value = 'sites/default/files/config_' . $config_directories_hash . '/sync';
  }
  if ($environment->field_ua_sm_hash_salt->isEmpty()) {
    // Generate a hash salt and store it for each new environment.
    $environment->field_ua_sm_hash_salt->value = Crypt::randomBytesBase64(55);
  }
}

/**
 * Populate an array with a list of entities and titles for display/use
 * in a select type box.
 *
 * @param string $type
 *   Provide choices for all entities of this type. E.g. ua_sm_platform.
 *
 * @return array
 *   The choices formatted as id => label.
 */
function ua_sm_custom_choices($type) {
  $ids = \Drupal::entityQuery('node')
    ->condition('type', $type)
    ->sort('title', 'ASC')
    ->execute();

  $entities = Node::loadMultiple($ids);

  $choices = [];
  foreach ($entities as $entity) {
    $choices[$entity->Id()] = $entity->getTitle();
  }

  return $choices;
}

/**
 * Populates the site instance with unique ports per host.
 *
 * @param Node $site_instance
 *   Site instance to assign free ports to.
 */
function ua_sm_custom_ports(Node $site_instance) {
  $server_id = $site_instance->field_ua_sm_server->target_id;
  $port_manager = \Drupal::service('ua_sm_custom.port_manager');
  $used_ports = $port_manager->getUsedPorts($server_id);

  // Find which ports have not already been allocated to the instance.
  $required_ports = [];
  foreach ($port_manager->port_fields as $port_field) {
    $port_number = $site_instance->{$port_field}->value;
    if (!$port_number) {
      $required_ports[] = $port_field;
    }
    elseif (in_array($port_number, $used_ports)) {
      // @todo Handle case where assigned port already in use.
      return;
    }
  }

  $available_port_numbers = $port_manager->getAvailablePorts($server_id, count($required_ports));
  if ($available_port_numbers) {
    foreach ($required_ports as $required_port) {
      $site_instance->get($required_port)->setValue(array_pop($available_port_numbers));
    }
  }
}

/**
 * Invalidate site entity caches because environments for sites have changed.
 *
 * @param EntityInterface $environment
 *   The environment entity whose site needs cache invalidate.
 */
function ua_sm_custom_invalidate_site_cache(EntityInterface $environment) {
  $site_nid = $environment->field_ua_sm_site->target_id;
  if ($site_nid) {
    \Drupal::service('cache_tags.invalidator')->invalidateTags(['node:' . $site_nid]);
  }
}

/**
 * Implements hook_entity_type_alter().
 *
 * Adds a constraint to node types to prevent exceeding the instance limit.
 */
function ua_sm_custom_entity_type_alter(array &$entity_types) {
  /** @var \Drupal\Core\Entity\ContentEntityType $node */
  $node = $entity_types['node'];
  $node->addConstraint('SiteInstance', [
    'limit' => UA_SM_CUSTOM_INSTANCE_LIMIT,
    'entity' => 'ua_sm_environment',
  ]);

}

/**
 * Implements hook_ENTITY_TYPE_insert().
 *
 * Triggers numerous actions when certain entities are created.
 *
 * Site:
 *  * Adds LDAP entries for each 'site_id#role' combination.
 *  * Synchronises any users for the site with LDAP.
 *  * Adds a default 'UAT' environment for the new site.
 *
 * Environment:
 *  * Creates new site instances on each of the selected platform's web servers.
 *
 * Site Instance:
 *  * Triggers the Jenkins provision job for the new site instance.
 */
function ua_sm_custom_node_insert(EntityInterface $entity) {
  switch ($entity->bundle()) {
    case 'ua_sm_site':
      if (\Drupal::config('ua_sm_custom.settings')->get('ldap')['enabled']) {
        // Add LDAP entries for each 'site_id#role' combination.
        $controlled_roles = array_keys(\Drupal::config('ua_sm_custom.settings')
          ->get('controlled_roles'));
        \Drupal::service('ua_ldap.ldap_site')
          ->addSite($entity->id(), $controlled_roles);
        // @todo Deal with failure - consider a queue.
        // Synchronise any users that were added to LDAP.
        \Drupal::service('ua_ldap.ldap_site')
          ->syncUsers($entity->id());
        // @todo Deal with failure - consider a queue.
      }

      // @todo Figure out which platform to default to. Maybe in config?
      // Fetch the ID of the first platform, we'll default to that for now.
      $platforms = \Drupal::entityQuery('node')
        ->condition('type', 'ua_sm_platform')
        ->execute();

      // Check if default environment should be automatically created.
      // Note fields presented only in the UI don't get setup as a node ->value.
      if (isset($entity->field_ua_sm_create_site) && $entity->field_ua_sm_create_site) {
        // Create default environment.
        $environment = Node::create([
          'type' => 'ua_sm_environment',
          'uid' => 1,
          'title' => 'UAT',
          'field_ua_sm_site' => $entity->id(),
          'field_ua_sm_platform' => isset($entity->field_ua_sm_platform) ? $platforms[$entity->field_ua_sm_platform] : reset($platforms),
          // @todo Convert environment types (e.g 'uat') to constants.
          'field_ua_sm_domain_name' => \Drupal::service('ua_sm_custom.hosts_config')
            ->generateDomainforEnv($entity->field_ua_sm_domain_name->value, 'uat'),
          'field_ua_sm_git_reference' => isset($entity->field_ua_sm_git_reference) ? $entity->field_ua_sm_git_reference : 'develop',
          'field_ua_sm_database_password' => \Drupal::service('ua_sm_custom.password')->generate(),
        ]);

        // Validate the environment, against any plugin constraints added.
        $validate = $environment->validate();
        $violations = $validate->getEntityViolations();
        if ($violations->count()) {
          foreach ($validate->getEntityViolations() as $violation) {
            drupal_set_message($violation->getMessage(), 'error');
            \Drupal::logger('ua_sm_custom')->info('Environment was not automatically created. %violation', array('%violation' => $violation->getMessage()));
          }
          // Prevent the environment from being created.
          break;
        }
        $environment->save();
      }
      break;

    case 'ua_sm_environment':
      // Load the selected environment.
      $platform = $entity->field_ua_sm_platform->first()->entity;

      // Create a new site instance for each of the platform's webservers.
      foreach ($platform->field_ua_sm_web_servers as $key => $web_server) {

        $site_instance_params = [
          'type' => 'ua_sm_site_instance',
          'uid' => 1,
          'title' => $entity->title->value . ' ' . ($key + 1),
          'field_ua_sm_environment' => $entity->id(),
          'field_ua_sm_server' => $web_server->entity->id(),
        ];
        // Add conditionals if environment has the following properties.
        if (isset($entity->backup_timestamp) && isset($entity->previous_env_id)) {
          $site_instance_params['backup_timestamp'] = $entity->backup_timestamp;
          $site_instance_params['backup_env_id'] = $entity->previous_env_id;
          $site_instance_params['isRestore'] = TRUE;
        }

        $site_instance = Node::create($site_instance_params);
        // Validate the site instance, against any plugin constraints added.
        $site_instance->validate();
        $site_instance->save();
      }
      ua_sm_custom_invalidate_site_cache($entity);
      break;

    case 'ua_sm_site_instance':
      if (\Drupal::config('ua_sm_custom.settings')->get('jenkins')['enabled']) {
        // @todo - check to see if
        if (isset($entity->isRestore) && $entity->isRestore) {
          // Run the restore job.
          ua_sm_custom_run_job('restore', $entity);
        }
        else {
          ua_sm_custom_run_job('provision', $entity);
        }
      }
      break;
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * Fetches a user's details from LDAP to fill out a provisioned account.
 */
function ua_sm_custom_user_presave(EntityInterface $entity) {
  if ($entity->isNew()) {
    \Drupal::service('ua_sm_custom.user')->populateFieldsFromLdap($entity);
    // @todo Consider breaking this functionality into its own module for reuse.
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * Synchronises a site's users to LDAP when it is updated, and triggers jenkins
 * jobs when an instance's status is changed.
 */
function ua_sm_custom_node_update(EntityInterface $entity) {
  switch ($entity->bundle()) {
    case 'ua_sm_site':
      if (\Drupal::config('ua_sm_custom.settings')->get('ldap.enabled')) {
        \Drupal::service('ua_ldap.ldap_site')->syncUsers($entity->id());
        // @todo Deal with failure - consider a queue.
      }
      break;

    case 'ua_sm_environment':
      ua_sm_custom_invalidate_site_cache($entity);
      break;

    case 'ua_sm_site_instance':
      if (\Drupal::config('ua_sm_custom.settings')->get('jenkins')['enabled']) {
        // Check if the published state of the site instance has changed.
        if ((int) $entity->status->value !== (int) $entity->original->status->value) {
          // If status has transitioned to published, run deploy, otherwise run
          // decommission.
          ua_sm_custom_run_job(
            $entity->status->value ? 'deploy' : 'decommission',
            $entity
          );

          // Finally, set the state field to indicate this transition.
          $entity->field_ua_sm_state->value = $entity->status->value ? 'starting' : 'stopping';
          $entity->save();
        }
      }
      break;
  }
}

/**
 * Implements hook_ENTITY_TYPE_predelete().
 *
 * Cascade the deletion of the environment by deleting its instances.
 */
function ua_sm_custom_node_predelete(EntityInterface $entity) {
  switch ($entity->bundle()) {
    case 'ua_sm_environment':
      $instance_ids = \Drupal::entityQuery('node')
        ->condition('type', 'ua_sm_site_instance')
        ->condition('field_ua_sm_environment', $entity->id())
        ->execute();
      $instances = Node::loadMultiple($instance_ids);
      foreach ($instances as $instance) {
        $instance->delete();
      }
      break;
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 *
 * Cleans up LDAP when sites are removed, and triggers jenkins when site
 * instances are deleted.
 */
function ua_sm_custom_node_delete(EntityInterface $entity) {
  switch ($entity->bundle()) {
    case 'ua_sm_site':
      if (\Drupal::config('ua_sm_custom.settings')->get('ldap')['enabled']) {
        // @todo Implement some sensible LDAP cleanup.
        // \Drupal::service('ua_ldap.ldap_site')->removeSite($entity->id());
        // @todo Deal with failure - consider a queue.
      }
      break;

    case 'ua_sm_environment':
      ua_sm_custom_invalidate_site_cache($entity);
      break;

    case 'ua_sm_site_instance':
      if (\Drupal::config('ua_sm_custom.settings')->get('jenkins')['enabled']) {
        ua_sm_custom_run_job('destroy', $entity);
      }
      break;
  }
}

/**
 * Implements hook_node_access().
 *
 * Prevent production environments from being deleted.
 */
function ua_sm_custom_node_access(EntityInterface $entity, $operation, AccountInterface $account) {
  if ($entity->bundle() == 'ua_sm_environment') {
    if ($operation == 'delete') {
      if ($entity->field_ua_sm_machine_name->value === 'prd') {
        return AccessResult::forbidden();
      }
    }
  }
  return AccessResult::neutral();
}

/**
 * Implements hook_entity_prepare_form().
 *
 * Automatically generates site admin and environment database passwords if they
 * are unset.
 */
function ua_sm_custom_entity_prepare_form(EntityInterface $entity) {
  switch ($entity->bundle()) {
    case 'ua_sm_site':
      $password_field = $entity->get('field_ua_sm_admin_password');
      $password = $password_field->value;
      if (!$password) {
        $password = \Drupal::service('ua_sm_custom.password')->generate();
        $password_field->setValue($password);
      }
      break;

    case 'ua_sm_environment':
      $password_field = $entity->get('field_ua_sm_database_password');
      $password = $password_field->value;
      if (!$password) {
        $password = \Drupal::service('ua_sm_custom.password')->generate();
        $password_field->setValue($password);
      }
      break;
  }
}

/**
 * Implements hook_entity_type_insert().
 */
function ua_sm_custom_comment_insert(EntityInterface $entity) {

  // Send an email notification to the user who created a site instance.
  $commented_entity = $entity->getCommentedEntity();

  if ($commented_entity->getType() === "ua_sm_site") {
    $author = $commented_entity->getRevisionAuthor();
    $author_email = $author->getEmail();

    $mail_message = [
      'author_name' => $author->field_ua_user_preferred_name->value ?: $author->getAccountName(),
      'message' => $entity->comment_body->value,
      'subject' => $entity->getSubject(),
    ];
    $langcode = $author->getPreferredLangCode();

    $result = \Drupal::service('plugin.manager.mail')->mail('ua_sm_custom', 'ua_sm_site', $author_email, $langcode, $mail_message);

    if ($result['result'] !== TRUE) {
      drupal_set_message(t('There was an issue sending an email notification to %email with message %msg', ['%email' => $author_email, '%msg' => $entity->comment_body->value]), 'error');
      return;
    }

    drupal_set_message(t('An email notification has been sent to %user', ['%user' => $author->field_ua_user_preferred_name->value]));
  }

}

/**
 * Implements hook_mail().
 */
function ua_sm_custom_mail($key, &$message, $params) {
  // Set the content of the email message, escape any html prior to send.
  switch ($key) {
    case 'ua_sm_site':
      $message['from'] = \Drupal::config('system.site')->get('mail');
      $message['subject'] = t('Site Instance : @subject', ['subject' => $params['subject']]);
      $message['body'][] = t('Hello @name,', ['name' => $params['author_name']]);
      $message['body'][] = \Drupal\Component\Utility\Html::escape($params['message']);
  }

}

/**
 * Implements hook_cron().
 */
function ua_sm_custom_cron() {

  // Back up all environments; only one site instance per environment.
  $site_instance_nids = \Drupal::entityQuery('node')
    ->condition('type', 'ua_sm_site_instance')
    ->execute();

  $instances = [];
  $nodes = Node::loadMultiple($site_instance_nids);

  foreach ($nodes as $node) {
    $environment_name = $node->field_ua_sm_environment->getString();
    if (!array_key_exists($environment_name, $instances)) {
      // Add once instance per environment, to be backed up.
      $instances[$environment_name] = $node;
    }
  }

  foreach ($instances as $instance) {
    \Drupal::service('ua_sm_custom.backup')->createBackup($instance);
  }

  // Update users attributes from LDAP.
  $user_ids = \Drupal::entityQuery('user')->execute();
  $users = User::loadMultiple($user_ids);
  foreach ($users as $user) {
    \Drupal::service('ua_sm_custom.user')->populateFieldsFromLdap($user);
    $user->save();
  }

}
